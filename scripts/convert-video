#!/bin/bash

set -e

quality=28  # Lower CRF means higher quality (range 0-51, 28 is a good default for x265)
trash_dir=""
base_dir=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --quality)
            quality="$2"
            shift 2
            ;;
        --trashbin)
            trash_dir="$2"
            shift 2
            ;;
        --basedir)
            base_dir="$2"
            shift 2
            ;;
        *)
            break
            ;;
    esac
done

if [ $# -lt 1 ]; then
    echo "Usage: $0 [--quality N] [--trashbin DIR] [--basedir DIR] <video_file>"
    exit 1
fi

video_file="$1"
base="${video_file%.*}"
output="${base}.mov"

# Expand ~ to $HOME if present
if [ -n "$trash_dir" ]; then
    trash_dir="${trash_dir/#\~/$HOME}"
fi
if [ -n "$base_dir" ]; then
    base_dir="${base_dir/#\~/$HOME}"
fi

echo "[$(date -Iseconds)] Starting conversion of $video_file to HEVC" >&2
echo "Debug: base_dir=$base_dir" >&2

# Check if input file exists
if [ ! -f "$video_file" ]; then
    echo "[$(date -Iseconds)] Error: Input file $video_file does not exist" >&2
    exit 1
fi

# Check if it's a video using ffprobe
if ! ffprobe -v error -select_streams v:0 -show_entries stream=codec_type -of default=noprint_wrappers=1:nokey=1 "$video_file" | grep -q "^video$"; then
    echo "[$(date -Iseconds)] Error: $video_file is not a valid video file" >&2
    exit 1
fi

# Check if input is already HEVC encoded
if ffprobe -v error -select_streams v:0 -show_entries stream=codec_name -of default=noprint_wrappers=1:nokey=1 "$video_file" | grep -q "^hevc$"; then
    echo "[$(date -Iseconds)] Error: Input file is already HEVC encoded" >&2
    exit 1
fi

# Convert the video
echo "[$(date -Iseconds)] Converting $video_file to HEVC" >&2
convert_cmd="ffmpeg -i \"$video_file\" -map 0 -c:v libx265 -preset slower -crf $quality -c:a libfdk_aac -profile:a aac_he_v2 -vbr 3 -c:s copy -tag:v hvc1 \"$output\""
echo "Debug: $convert_cmd" >&2
if ! eval "$convert_cmd"; then
    echo "[$(date -Iseconds)] Error: Conversion failed" >&2
    exit 1
fi

# Verify the output file exists
if [ ! -f "$output" ]; then
    echo "[$(date -Iseconds)] Error: Output file verification failed" >&2
    exit 1
fi

# Move original to trash if specified
if [ -n "$trash_dir" ]; then
    if [ -n "$base_dir" ]; then
        # Get path relative to base directory without using realpath
        full_video_path="$(cd "$(dirname "$video_file")" && pwd)/$(basename "$video_file")"
        full_base_path="$(cd "$base_dir" && pwd)"
        rel_path="${full_video_path#$full_base_path/}"
        trash_path="$trash_dir/$rel_path"
        echo "Debug: full_video_path=$full_video_path" >&2
        echo "Debug: full_base_path=$full_base_path" >&2
        echo "Debug: rel_path=$rel_path" >&2
        echo "Debug: trash_path=$trash_path" >&2
    else
        # Fallback to just filename if no base directory specified
        filename="$(basename "$video_file")"
        trash_path="$trash_dir/$filename"
        echo "Debug: using basename=$filename" >&2
        echo "Debug: trash_path=$trash_path" >&2
    fi

    # Create parent directory structure
    trash_dir_path="$(dirname "$trash_path")"
    mkdir -p "$trash_dir_path"

    echo "[$(date -Iseconds)] Moving original file to $trash_path" >&2
    if ! mv "$video_file" "$trash_path"; then
        echo "[$(date -Iseconds)] Error: Failed to move original file to trash" >&2
        exit 1
    fi
fi

echo "[$(date -Iseconds)] Successfully converted $video_file to HEVC" >&2 